# Basic

## 알고리즘

- **정당성:** 입력값이 지정된 조건과 일치한다면 알고리즘은 반드시 정상적인 동작(올바른 출력값의 반환)을 보장해야 한다.
  
  - **단정문(Assertion):** 알고리즘의 실행 순서 중 임의의 위치에 서서 충족해야 하는 조건이 성립하는지의 여부(올바르게 동작하는지의 여부)를 체크하는 것

- **정지성:** 어떠한 조건의 입력값이 주어지더라도 정해진 시간 내에 반드시 정상적인 종료를 보장하는 것. 영원히 처리를 반복하여 답을 돌려주지 않는 처리(무한 루프)는 알고리즘이 아니다.

- **주요 알고리즘**
  
  - **기술 계산:** 유클리드 호제법(최대공약수), 가우스 소거법(방정식), 사다리꼴의 법칙(정적분), 데이크스트라 알고리즘(최적 경로), 에라토스테네스의 체(소수)
  - **정렬(Sort):** 단순 선택 정렬, 단순 교환 정렬(버블 정렬), 단순 삽입 정렬, 셸 정렬, 병합 정렬, 퀵 정렬
  - **검색(Search):** 선형 검색(리니어 서치), 이진 검색(바이너리 서치)
  - **문자열 패턴 매칭:** 단순 문자열 일치, KMP 알고리즘, BM 알고리즘

- **구조적 프로그래밍**
  
  - **순차 구조:** 작성된 순서대로 순차 실행한다.
  - **선택 구조:** 조건에 따라 수행할 작업의 흐름을 바꾼다.
  - **반복 구조:** 조건이 일치하는 동안 일정 과정을 반복해서 실행한다.

## 자료구조

### 주요 자료구조

- 배열
  
  데이터를 빈틈없이 나열한 자료구조
  
  일직선 상에 빈틈없이 데이터를 나열한 1차원 배열,
  
  가로세로 빈틈없이 데이터를 나열한 2차원 배열,
  
  직육면체처럼 가로, 세로, 높이에 빈틈없이 데이터를 나열한 3차원 배열 등

- 리스트
  
  데이터를 순서대로 나열한 자료구조
  
  배열과 같이 차례대로 나열한 데이터를 관리한다.
  
  그러나 데이터들이 화살표로 서로 연결되어 있어 데이터들이 떨어진 장소에 위치해도 된다는 점이 배열과 다르다.

- 스택
  
  책상 위에 책을 쌓듯 데이터를 관리하는 자료구조
  
  데이터를 넣는 순서와 반대의 순서로 데이터를 꺼내는 데이터 관리 방법

- 큐 (대기 행렬)
  
  데이터를 넣은 순서대로 데이터를 꺼내는 데이터 관리 방법

- 트리 (나무 구조)
  
  나뭇가지가 2개, 3개, ... 로 갈라지고, 그 갈라진 끝에서 2개, 3개, ... 나뉘듯 퍼져나가는 자료구조

### 스택(Stack)

- 데이터를 쌓아서 관리하는 방식. 데이터를 넣는 순서와 반대의 순서로 데이터를 꺼냄

- 스택을 사용한 데이터 관리법에서
  
  1. 데이터를 넣는(쌓는) 작업: 푸시(PUSH)
  
  2. 데이터를 꺼내는 작업: 팝(POP)

- LIFO(Last In, First Out) 또는 FILO(First In, Last Out):
  
  - 마지막에 입력된 데이터가 먼저 출력되는 특징을 갖는 데이터 관리 방법

### 큐(Queue, 대기 행렬)

- 먼저 입력한 데이터가 먼저 출력되는 특징을 가진 자료구조

- FIFO(First in, First Ount) 또는 LILO(Last In, Last Out):
  
  - 먼저 입력한 데이터가 먼저 출력되는 특징을 갖는 데이터 관리 방법

### 리스트

- 데이터를 순서대로 나열한 자료구조

- 배열은 데이터를 저장하는 상자들이 정해진 위치에 있으므로 데이터의 순서를 파악할 수 있는 구조

- 리스트는 각 데이터들이 방향성을 가진 끈으로 연결되어 있어, 데이터의 위치가 바뀌더라도 그 끈을 추적하면 다음 데이터의 위치를 파악할 수 있음
  
  데이터의 위치에 관계없이 데이터의 순서를 관리할 수 있음

- 유효한 데이터의 개수를 관리할 때 
  
  - 배열에서는 다른 변수를 사용
  
  - 리스트에서는 '다음 데이터에 연결된 끈이 있는지의 여부'로 데이터의 끝을 파악

#### 단방향 리스트

- 리스트 안에서 앞쪽에서 뒷쪽을 가리키는 방향성을 가진 끈으로 순서가 있는 데이터를 연결하는 방식

- 단방향 리스트의 각 요소는 2가지 항목을 가지고 있다.
  
  - 데이터:
    
    - 그 요소에 저장된 정수와 실수, 문자열 등 리스트에서 관리하고자 하는 값
  
  - 다음 요소를 가리키는 포인터:
    
    - 요소와 요소를 연결하는 끈의 역할
    
    - 'NEXT 포인터': 다음 요소가 어디에 있는지를 나타내는 위치 정보가 저장
    
    - 마지막 요소에는 다음요소가 더이상 없다는 뜻의 종료 정보가 저장

- 'HEAD포인터': 1번째 요소를 가리키는 포인터, 1번째 요소의 위치 정보가 저장

- 단방향 리스트는 HEAD 포인터가 가리키는 요소에서 시작하고 NEXT 포인터가 종료 정보를 저장한 요소에서 끝난다.

- 리스트에 데이터가 하나도 없을 경우 HEAD 포인터에 '1번째 요소가 없다'는 정보를 저장

#### 양방향 리스트

- 리스트의 안에서 앞에서부터 뒤를 가리키는 끈과 뒤에서 앞을 가리키는 끈 2개를 사용하여 순서가 있는 데이터들을 연결하는 방법

- 양방향 리스트의 각 요소는 3가지 항목을 가지고 있다.
  
  - 데이터: 
    
    - 그 요소에 저장된 정수와 실수, 문자열 등 리스트에서 관리하고자 하는 값
  
  - 다음 요소를 가리키는 포인터:
    
    - 바로 다음(후방) 요소를 잇는 끈의 역할
    
    - NEXT 포인터: 다음 요소가 어디에 있는지를 표시하는 위치 정보가 저장
  
  - 이전 요소를 가리키는 포인터:
    
    - 바로 이전(전방)의 요소를 잇는 끈의 역할
    
    - PREV 포인터: 이전 요소가 어디에 있는지를 표시하는 위치 정보가 저장

- 마지막 요소인 NEXT 포인터와 1번째 요소의 PREV 포인터에는 '다음 요소 없음' 이라는 종료정보가 저장

- HEAD 포인터: 1번째 요소를 가리키는 포인터, 1번째 요소의 위치 정보가 저장

- TAIL 포인터: 마지막 요소를 가리키는 포인터, 마지막 요소의 위치 정보가 저장

- 리스트에 데이터가 하나도 없는 경우 HEAD포인터와 TAIL 포인터 모두에 '1번째 요소 없음'이라는 정보가 저장

#### N번째 요소 조회

- 배열:
  
  - 요소 번호를 사용해 바로 찾을 수 있음

- 리스트:
  
  - 1번째 데이터부터 차례대로 끈을 따라가야 함
  
  - 5번째 요소를 조회하기 위해서는 5단계의 조작이 필요

- N번째 요소를 참조할 때는 배열이 리스트보다 훨씬 더 효율적

#### 데이터 삽입

새로운 데이터를 순서대로 나열된 데이터 열의 특정 위치에 삽입하는 경우,

- 배열:
  
  - 삽입 위치 다음에 존재하는 모든 데이터를 뒤로 이동시켜야 함
  
  - 1개의 데이터를 삽입할 때마다 데이터 이동 프로세스가 발생하기에 시간적인 비용이 매우 커짐

- 리스트:
  
  - 삽입하는 데이터의 앞뒤 데이터를 연결하고 있는 끈을 잘라 새로운 데이터에 연결
  
  - '끈을 자르고 합치기' 작업을 1번만 수행하면 삽입할 수 있어, 시간적인 비용이 적음

#### 데이터 삭제

- 배열:
  
  - 삭제된 데이터보다 뒤에 있는 데이터를 모두 앞으로 옮겨야 함

- 리스트:
  
  - 제거하고자 하는 데이터의 끈을 자른 후 앞뒤 데이터를 이어 붙이기만 하면 됨

- 데이터를 삽입하고 삭제할 때는 리스트가 배열보다 효율적

### 링 버퍼

- 시작과 끝이 있는 1차원 배열의 1번째 요소와 마지막 요소를 합쳐 '배열 마지막 요소의 다음에도 요소가 존재한다'고 만드는 자료구조

- '배열 마지막 요소의 다음 요소를 배열 1번째 요소로 삼는다'고 정하여 1차원 배열의 '다음 요소'를 영원히 조회할 수 있음

- 링 버퍼의 첨자는 아날로그 시계의 숫자판에 비유할 수 있음

- 링 버퍼는 가장 오래된 데이터를 버리는 FIFO의 큐 구조를 구현할 때 유용
  ex) 최근 발생한 수십건의 정보를 유지해야 하는 휴대전화의 통화이력 구현에 활용가능

### 이진 트리(바이너리 트리)

- '다음 요소를 가리키는 포인터'를 2개 가진 단방향 리스트의 일종

- 데이터 X의 다음 요소로 L과 R, 2개의 데이터가 존재할 때,
  
  - **노드**: 이진 트리의 구성요소
  
  - **부모 노드**: 데이터 X
  
  - **자식 노드**: 데이터 L과 R
    
    - R: '오른쪽', L: '왼쪽'
    
    - 이진 트리에 자식 노드가 반드시 좌우에 2개 있을 필요는 없지만,
      
      부모 노드는 자식 노드를 3개 이상 가질 수 없다.
    
    - 자식 노드도 그 아래의 자식 노드의 기준에서 본다면 부모 노드이기도 하다.

- **뿌리** 또는 **루트 노드**: 
  
  - 이진 노드에서 모든 노드의 시작점인 노드, 즉 부모 노드가 없는 노드

- **잎** 또는 **리프**:
  
  - 말단 노드, 즉 자식 노드가 없는 노드

- **깊이**: 뿌리에서 특정한 노드에 도달하기까지의 경로의 길이

#### 힙

- 각 노드의 값이 다음 조건을 충족하도록 관리되는 이진 트리

- 조건: 부모 노드의 값은 항상 하위 노드의 값보다 작다
  
  (또는 부모 노드의 값은 항상 하위 노드의 값보다 크다.)
  
  - 자식 노드의 값은 둘 중 어느 쪽이 크더라도 상관 없다.

- 뿌리에 '모든 값 중에서 가장 작은 값 (또는 가장 큰 값)'이 배치 됨

- 힙에서 '최소값 (또는 최대값)'은 '뿌리' 노드의 값

- 힙을 구현할 때 배열을 사용. 
  
  - 배열 요소 번호는 힙의 뿌리를 1번째 요소로,
  
  - '깊이'는 작은 쪽에서 큰 쪽으로,
  
  - 노드의 왼쪽에서 오른쪽 방향으로 대입
    
    - 힙에서 관리하는 값을 배열에 저장할 때는 위에서 아래로, 깊이가 같다면 왼쪽에서 오른쪽으로 저장
    
    - '최소값 (또는 최대값)'은 항상 배열의 1번째 요소에 저장됨

### 해시 테이블

- N개의 요소를 가진 루트 배열이라는 이름의 배열 + 루트 배열의 각 요소들이 가리키는 리스트

- 해시 테이블로 데이터를 관리하려면, 루트 배열의 각 요소들이 가리키는 리스트 중에서 어떤 리스트에 저장할 지를 결정해야 함
  
  즉 루트 배열의 요소 번호부터 구해야 함
  
  - 해시 함수: 요소 번호를 구할 때 사용하는 도구
    
    관리할 데이터를 입력 받아서, 그 데이터를 해쉬 값('0 ~ (N-1)' 사이의 값)으로 바꾸어 주는 함수 (N은 루트 배열의 요소 개수)
  
  - 해시 값을 루트 배열의 요소 번호로 삼으면, 데이터를 루트 배열의 몇번째 요소가 가리키는 리스트에 저장해야 할 지 결정할 수 있다.

- 충돌: 
  
  각 그룹별로 데이터가 하나만 있다면 데이터 관리는 루트 배열만으로 충분하지만,
  
  많은 양의 데이터를 해시 테이블로 관리하려고 할 때 같은 배열 요소에 그룹화된 데이터가 여러 개 나오는 상황
  
  - 각각의 그룹이 여러 개의 데이터를 관리할 수 있도록 만들어야 하기에,
    
    루트 배열의 각 요소가 리스트를 가리키도록 만들면
    
    해시 값이 동일한 데이터들을 여러 개 관리할 수 있다.

- 해시 테이블이 관리하는 데이터 중에서 특정한 데이터를 찾을 때
  
  - 찾고자 하는 데이터의 해시 값부터 먼저 구해서, 찾고자 하는 데이터가 속한 그룹을 찾는다.
  
  - 그 후 해당 그룹의 리스트 안의 데이터만 순서대로 검색한다.

### 그래프

- 2개 이상의 항목이 어떤 관계를 맺고 있는지에 주목하고 그 관계를 그림으로 표현한 것

- 정점(노드): 그래프에서 표현하는 항목

- 간선(Edge): 각 항목들의 관계를 표현하는 선

- 방향있는 그래프: 간선에 방향성이라는 특성을 부여한 그래프

- 방향없는 그래프: 방향성이 없는 간선

- 가중 그래프: 간선에 가중치(비용)가 붙어있는 그래프

---

> #### Base는 0? 1?
> 
> - 배열 1번째 요소의 번호가 0부터 시작하는 케이스와 1부터 시작하는 케이스 두 개가 존재하는 이유는, 1번째 요소의 번호를 0으로 정한 프로그래밍 언어와 1로 정한 프로그래밍 언어가 존재하기 때문
> 
> - 컴퓨터 개발 초창기의 프로그래밍에 사용되던 언어들에서는 배열의 1번째 요소 번호를 1로 정한 알고리즘을 고안했다.
>   
>   - ex) Fortran, Pascal, Basic(초기형) 등
> 
> - 그 후에 주류가 되어서 지금도 널리 이용되고 있는 프로그래밍 언어들에서는 배열의 1번째 요소 번호를 0으로 정하는 사양을 채택했다.
>   
>   - ex) C, C++, Java, C#, VisualBasic(BASIC) 등
> 
> - 따라서 현재는 배열의 1번째 요소 번호를 0으로 정하고 알고리즘을 작성하는 것이 일반적이다.
