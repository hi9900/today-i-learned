# 05_data_structure

# Python 05

## 데이터 구조(Data Structure)

- 여러 데이터를 효과적으로 사용, 관리하기 위한 구조
- 파이썬에는 대표적으로 List, Tuple, Dict, Set 등의 데이터 구조가 있음

> 자료구조
> 
- 컴퓨터 공학에서는 ‘자료구조’라고 함
- 각 데이터의 효율적인 저장, 관리를 위한 구조를 나눠놓은 것

### 데이터구조 활용하기

- 데이터 구조를 활용하기 위해서는 메서드(methond)를 사용
    - 메서드는 클래스 내부에 정의한 함수, 사실상 함수와 동일
    - 쉽게 설명하면 객체의 기능
    - `데이터구조.메서드()` 형태로 사용
    
    > 파이썬 공식문서의 표기법
    > 
    - python 구문이 아니며, 문법을 표현하기 위한 것
    - `str.replace(old, new[,count])` 에
        - old, new는 필수,`[ ,count]`는 선택적 인자를 의미함

## 순서가 있는 데이터 구조

### 문자열(Stirng Type)

- 문자들의 나열(sequence of characters)
    - 모든 문자는 str 타입(변경 불가능한 immutable)
- 문자열은 작은 따옴표(')나 큰 따옴표(")를 활용하여 표기
    - 문자열을 묶을 때 동일한 문장 부호를 활용
    - PEP8에서는 소스코드 내 하나의 문장부호를 선택하여 유지하도록 함

> 문자열 조회/탐색 및 검증 메서드
> 

| 문법 | 설명 |
| --- | --- |
| s.find(x) | x의 첫 번째 위치를 반환. 없으면 -1을 반환 |
| s.index(x) | x의 첫 번째 위치를 반환. 없으면 오류 발생 |
| s.isalpha() | 알파벳 문자 여부
단순 알파벳이 아닌 유니코드 상 Letter (한국어도 포함) |
| s.isupper() | 대문자 여부 |
| s.islower() | 소문자 여부 |
| s.istitle() | 타이틀 형식 여부 |

> 문자열 관련 검증 메서드
> 

`s.iscecimal()` ⊆ `s.isdigit()` ⊆ `s.isnumeric()`

> 문자열 변경 메서드
> 

| 문법 | 설명 |
| --- | --- |
| s.replace(old, new[, count]) | 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
count를 지정하면 해당 개수만큼만 시행 |
| s.strip([chars]) | 공백이나 특정 문자를 제거 |
| s.split(sep=None, maxsplit=-1) | 공백이나 특정 문자를 기준으로 분리
sep이 None이거나 지정되지 않으면 공백문자
maxsplit이 -1인 경우에는 제한이 없음 |
| “separator”.join([iterable]) | 구분자(separator)로 iterable을 합쳐 문자열 반환 |
| s.capitalize() | 가장 첫 번째 글자를 대문자로 변경 |
| s.title() | 문자열 내 띄어쓰기 기준으로 각 단어의 첫글자는 대문자로, 나머지는 소문자로 변환 |
| s.upper() | 모두 대문자로 변경 |
| s.lower() | 모두 소문자로 변경 |
| s.swapcase() | 대↔소문자 서로 변경 |

> 문자열은 immutable인데, 문자열 변경이 되는 이유는
> 
- 기존의 문자열을 변경하는 것이 아니라, 변경된 문자열을 새롭게 만들어서 반환

### 리스트(List)

- 리스트는 여러개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
- 리스트는 대괄호([]) 혹은 list()를 통해 생성
    - 파이썬에서는 어떠한 자료형도 저장할 수 있으며, 리스트 안에 리스트도 넣을 수 있음
    - 생성된 이후 내용 변경이 가능 → 가변자료형
    - 이러한 유연성 때문에 파이썬에서 가장 흔히 사용
- 순서가 있는 시퀀스로 인덱스를 통해 접근 가능

> 리스트 메서드
> 

| 문법 | 설명 |
| --- | --- |
| l.append(x) | 리스트 마지막에 항목 x를 추가 |
| l.insert(i, x) | 리스트 인덱스 i에 항목 x를 삽입 |
| l.extend(iterable) | 리스트에 iterable의 항목을 추가 (+= 와 같은 기능) |
| l.remove(x) | 리스트 가장 왼쪽에 있는 항목(첫 번째) x를 제거
항목이 존재하지 않을 겨우 ValueError |
| l.pop(i) | 리스트의 인덱스 i에 있는 항목을 반환 후 제거
i가 지정되지 않으면 마지막 항목을 반환 후 제거 |
| l.clear() | 리스트의 모든 항목 삭제 |
| l.index(x) | 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환 |
| l.count(x) | 리스트에서 항목 x의 개수를 반환 |
| l.sort() | 원본 리스트를 정렬(매개변수 이용 가능)
None 반환, sorted 함수와 비교 |
| l.reverse() | 리스트의 순서를 반대로 뒤집음 (정렬하는 것은 아님) |

### 튜플

- 튜플은 여러개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
    - 리스트와 다르게 생성 후, 담고있는 값 변경이 불가(불변 자료형)
- 항상 소괄호 형태로 사용
- 튜플은 변경할 수 없기 때문에 값에 영향을 미치지 않는 메서드만을 지원
- 리스트 메서드 중 항목을 변경하는 메서드들을 제외하고 대부분 동일

## 순서가 없는 데이터 구조

### 셋(Set)

- Set이란 중복되는 요소가 없이, 순서에 상관없는 데이터들의 묶음
    - 데이터의 중복을 허용하지 않기 때문에 중복되는 원소가 있다면 하나만 저장
    - 순서가 없기 때문에 인덱스를 이용한 접근 불가능
- 수학에서의 집합을 표현한 컨테이너
    - 집합 연산이 가능(여집합을 표현하는 연산자는 별도로 존재 x)
    - 중복된 값이 존재하지 않음
- 담고 있는 요소를 삽입, 변경, 삭제 가능 -> 가변 자료형(mutable)

> 셋 메서드
> 

| 문법 | 설명 |
| --- | --- |
| s.copy() | 셋의 얕은 복사본을 반환 |
| s.add(x) | 항목 x가 셋 s에 없다면 추가 |
| s.update(t) | 셋 t에 있는 모든 항목 중 셋 s에 없는 항목을 추가 |
| s.remove(x) | 항목 x를 셋 s에서 삭제
항목이 존재하지 않는 경우 KeyError |
| s.discard(x) | 항목 x가 셋 s에 있는 경우, 항목 x를 셋 s에서 삭제 |
| s.pop() | 셋 s에서 랜덤하게 항목을 반환하고, 해당 항목을 제거
set이 비어있는 경우 KeyError |
| s.clear() | 셋의 모든 항목을 제거 |
| s.isdisjoint(t) | 셋 s가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우, True 반환(서로소) |
| s.issubset(t) | 셋 s가 셋 t의 하위 셋인 경우, True 반환 |
| s.issuperset(t) | 셋s가 셋 t의 상위 셋인 경우, True 반환 |

### 딕셔너리(Dictionary)

- 키-값(key-value) 쌍으로 이뤄진 자료형 (3.7부터는 orderes, 이하 버전은 unordered)
- Dictionary의 키(Key)
    - key는 변경 불가능한 데이터(immutable)만 활용 가능
        - string, integer, float, boolean, tuple, range
- 각 키의 값(values)
    - 어떠한 형태든 관계없음

> 딕셔너리 메서드
> 

| 문법 | 설명 |
| --- | --- |
| d.clear() | 딕셔너리의 모든 항목을 제거 |
| d.copy() | 딕셔너리의 얕은 복사본을 반환 |
| d.keys() | 딕셔너리의 모든 키를 담은 뷰를 반환 |
| d.values() | 딕셔너리의 모든 값을 담은 뷰를 반환 |
| d.items() | 딕셔너리의 모든 키-값의 쌍을 담은 뷰를 반환 |
| d.get(key[, default]) | key 값을 반환하는데, key가 딕셔너리 d에 없을 경우 default 값을 반환
없을경우 None |
| d.pop(key[, default]) | key 값을 반환하고 딕셔너리 d에서 삭제
key가 딕셔너리에 없고, default값이 없으면 KeyError |
| d.update([other]) | 딕셔너리 d의 값을 매핑하여 업데이트 |

## 연산자(Operator)

### 멤버십 연산자(Membership Operator)

- 멤버십 연산자를 통해 특정 요소가 속해 있는지 여부를 확인
- 포함여부 확인: `in`, `not in`

### 시퀀스형 연산자(Sequence Type Operator)

- 산술연산자 `+`
    - 시퀀스 간의 concatenation(연결/연쇄)
- 반복 연산자 `*`
    - 시퀀스를 반복

## 얕은 복사와 깊은 복사(Shallow Copy & Deep Copy)

### 할당(Assignment)

- 대입 연산자 (=)
    - 대입 연산자를 통한 복사는 해당 객체에 대한 객체 참조를 복사
    - 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향

### 얕은 복사(Shallow Copy)

- Slice 연산자를 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사(다른 주소)
- 복사하는 리스트의 원소가 (다른 리스트) 주소를 참조하는 경우

### 깊은 복사(Deep Copy)

- 리스트를 복사하고 싶다면 무조건 print로 변화를 확인
- 모두 copy.deepcopy()를 쓰면 메모리 용량 증가